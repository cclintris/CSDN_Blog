# 理解 React + SSR 整体架构

[TOC]

# 前言

随著前端技术发展更新的越来越快，这几年陆续推出了许多新框架，像是 Vue, React 等等，此外，也对于前端性能上越来越重视其性能、资源消耗等。本篇文章要来介绍关于 SSR 这个技术，为什麽有 SSR 德出现，适用场景以及原理。

# 正文

SSR 的全称是 Server Side Rendering，顾名思义就是服务端渲染。要了解 SSR，有一个重要的概念『同构』，必且也要理解客户端渲染和服务端渲染的区别，这边就来先釐清下这三个概念。

## 客户端渲染

客户端渲染指的是说：

> 页面初始加载的 HTML 页面中没有内容展示，啥都没有，需要加载执行 JavaScript 文件中的 React 代码，通过 JavaScript 渲染生成页面，同时，JavaScript 代码会完成页面交互事件的绑定，详细流程可参考下图：

- Client Side Render

（图片来自 fullstackacademy.com）

![](https://obohe.com/i/2021/07/10/zhyt4q.jpg)

## 服务端渲染

服务器端渲染指的是说：

> 用户请求服务器，服务器上直接生成所有需要的 HTML 内容并返回给浏览器。一般来说，服务器端渲染的页面交互能力有限，如果要实现複杂的交互，还是要通过引入 JavaScript 文件来辅助实现。

（图片来自 fullstackacademy.com）

![](https://obohe.com/i/2021/07/10/zhznp6.jpg)

## 同构

同构这个概念存在于 Vue，React 这些新型的前端框架中，同构实际上是客户端渲染和服务器端渲染的一个整合。我们把页面的展示内容和交互写在一起，让代码执行两次。在服务端执行一次，用于实现服务端渲染，在客户端再执行一次，用于接管页面交互。

- Server Side Render

（图片来自 fullstackacademy.com）

![](https://obohe.com/i/2021/07/10/zi0y9m.jpg)

其实一般情况下，当我们使用 react 时，页面都是交给客户端的浏览器直接执行 js 生成 DOM 的，我们常听到的 SPA(Single Page Application)单页面应用实际上就都是採用 CSR 模式。那既然这样，为什麽需要引入 SSR 呢？

## Why SSR ?

SSR 之所以出现以及越来越主流，主要是因为下面两个因素：

1. 传统的 CSR 的 TTFP(Time To First Page) 会比较长，因为在 CSR 的页面渲染流程中，首先要先加载 html 文件，然后要下载页面所需要的 js 文件、css 文件等，然后具体其实由 js 文件渲染生成页面。在这样的渲染过程中至少涉及到两次 http 请求週期，请求 html 文件和 js 文件。其实这也就是为什麽有时候我们在网路状态较不好的环境下访问普通的 react 或是 vue 项目时，会加载比较久甚至出现白屏的情况。

2. CSR 的 SEO 能力极差，基本在搜索引擎中不可能会有好的排名。这是因为其实目前主流的搜索引擎还是以识别 html 为主，对 js 文件的识别能力还是较弱。如果项目的流量入口来源主要依赖于搜索引擎，这个时候还使用 CSR 进行开发就不太合适了。

## SSR 架构

但是其实 SSR 的出现以及这种渲染架构的实现并非一件简单的事情，看看下图关于 React 中实现 SSR 技术的架构图：

![](https://obohe.com/i/2021/07/11/2a9bts.jpg)

个人理解，使用 SSR 来渲染页面确实可以大大提升页面渲染的效率和整体性能，但项目的可维护性会降低，且代码的可读性也会变得比较不好，且项目模块之间的耦合度会大幅度提高。

分析一下这张架构图。上面说到在 SSR 的架构中，我们要让组件的代码运行两次，一次在服务端一次在客户端。

看到在第 6 步之前，所有的步骤其实就是在完成服务端渲染，这时候返回回来的 html 已经是一个可以看到的完整的介面的，只不过可能还缺少一些与用户交互的功能，这也就是纯 SSR 的缺点，所以接下来我们还要通过客户端渲染来完成交互接管的任务。

继续可以看到，在获取到基本的 html 页面后，浏览器就会开始要加载 bundle.js，而使用过基本的 webpack 就会知道，这个文件就是当你执行 `npm run build` 打包项目后，默认会出现在 /dist 下的一个打包文件，而这个文件也就包含的是与用户交互相关的 js 代码。

然后组件除了自己一开始渲染所需的基本数据(props)之外，可能还会需要一些其他数据，这时候就由 bundle.js 中再次向 api 服务器发起请求，具体如图中，会先由 node 进行代理最后才获得数据，最终完成客户端渲染。

## SSR 与 VDOM 的关係

SSR 的整个过程中，React 代码会在客户端和服务器端各执行一次。你可能会想，这没什么问题，都是 JavaScript 代码，既可以在浏览器上运行，又可以在 Node 环境下运行。但事实并非如此，如果你的 React 代码里，存在直接操作 DOM 的代码，那么就无法实现 SSR 这种技术了，因为在 Node 环境下，是没有 DOM 这个概念存在的，所以这些代码在 Node 环境下是会报错的。

好在 React 框架中引入了一个概念叫做虚拟 DOM，虚拟 DOM 是真实 DOM 的一个 JavaScript 对象映射，React 在做页面操作时，实际上不是直接操作 DOM，而是操作虚拟 DOM，也就是操作普通的 JavaScript 对象，这就使得 SSR 成为了可能。

在服务端，我可以操作 JavaScript 对象，判断环境是服务器环境，我们把虚拟 DOM 映射成字符串输出；在客户端，我也可以操作 JavaScript 对象，判断环境是客户端环境，我就直接将虚拟 DOM 映射成真实 DOM，完成页面挂载。

其他的一些框架，比如 Vue，它能够实现 SSR 也是因为引入了和 React 中一样的虚拟 DOM 技术。

好，接下来我们回过头看流程图，前两步不说了，服务器端渲染肯定要先向 Node 服务器发送请求。重点是第 3 步，可以看到，服务器端要根据请求的地址，判断要展示什么样的页面，具体是哪一个组件，这一步叫做服务器端路由。

我们再看第 10 步，当客户端接收到 JavaScript 文件后，要根据当前的路径，在浏览器上再判断当前要展示的组件，重新进行一次客户端渲染，这个时候，还要经历一次客户端路由（前端路由）。
那么，下面要说的就是服务器端路由和客户端路由的区别。

## SSR 客户端渲染 vs 服务端渲染

实现 React 的 SSR 架构，我们需要让相同的 React 代码在客户端和服务器端各执行一次。大家注意，这里说的相同的 React 代码，指的是我们写的各种组件代码，所以在同构中，只有组件的代码是可以公用的。

而路由这样的代码是没有办法公用的，原因是因为，在服务器端需要通过请求路径，找到路由组件，而在客户端需则是需要通过浏览器中的 url，找到路由组件，是完全不同的两套机制，所以这部分代码是肯定无法公用。

我们来看看在 SSR 中，前后端路由的实现代码，大体长什麽样子以及不同之处：

### 服务端路由

```js
const App = () => {
  return 
    <Provider store={store}>
      <StaticRouter location={req.path} context={context}>
        <div>
          <Route path='/' component={Home}>
        </div>
      </StaticRouter>
    </Provider>
}

return ReactDOM.renderToString(<App />)
```
服务器端路由代码相对要复杂一点，需要你把 location（当前请求路径）传递给 `StaticRouter` 组件，这样 `StaticRouter` 才能根据路径分析出当前所需要的组件是谁。

>（PS：`StaticRouter` 是 React-Router 针对服务器端渲染专门提供的一个路由组件。）

### 客户端路由

```js
const App = () => {
  return (
    <Provider store={store}>
      <BrowserRouter>
        <div>
          <Route path='/' component={Home}>
  		  </div>
      </BrowserRouter>
    </Provider>
  )
}

ReactDOM.render(<App />, document.querySelector('#root'))
```
客户端路由代码比较简单，`BrowserRouter` 会自动从浏览器地址中，匹配对应的路由组件显示出来。

通过 `BrowserRouter` 我们能够匹配到浏览器即将显示的路由组件，对浏览器来说，我们需要把组件转化成 DOM，所以需要我们使用 `ReactDOM.render` 方法来进行 DOM 的挂载。而 `StaticRouter` 能够在服务器端匹配到将要显示的组件，对服务器端来说，我们要把组件转化成字符串，这时我们只需要调用 ReactDom 提供的 `renderToString` 方法，就可以得到 App 组件对应的 HTML 字符串。

对于一个 SSR + React 应用来说，路由一般是整个程序的执行入口。在 SSR 中，服务器端的路由和客户端的路由不一样，也就意味著服务器端的入口代码和客户端的入口代码是不同的。

## Node 只是一个中间层

在 SSR 架构中，一般 Node 只是一个中间层，用来做 React 代码的服务器端渲染，而 Node 需要的数据通常由 API 服务器单独提供。

这样做一是为了工程解耦，二也是为了规避 Node 服务器的一些计算性能问题。

关注图中的第 4 步和第 12，13 步，接下来分析这几个步骤。

服务器端渲染时，直接请求 API 服务器的接口获取数据没有任何问题。但是在客户端，就有可能存在跨域的问题了，所以，这个时候，我们需要在服务器端搭建 Proxy 代理功能，客户端不直接请求 API 服务器，而是请求 Node 服务器，经过代理转发，拿到 API 服务器的数据。

# 结语

这篇大致上介绍了关于 React + SSR 的基本架构和一些重要的概念，整体上算是一种全新的渲染方案，确实有他的独到之处，不过在理解上确实不是那麽容易，还需要更多的著墨。之后关于 React + SSR 还会再写几天关于简单的实现，加入 redux，api 等等，更好地加深对 SSR 的融会贯通。