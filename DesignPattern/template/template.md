@[TOC](Java 設計模式 - 模板方法模式)

# 模板方法模式前言

在面向對象程序設計過程中，我們常常會遇到這種情況：設計一個系統時知道了算法所需的關鍵步驟，而且確定了這些步驟的執行順序，但某些步驟的具體實現還不知道，或者說某些步驟的實現與具體的環境相關。

例如，去銀行辦理業務一般要經過以下 4 個流程：取號、排隊、辦理具體業務、對銀行工作人員進行評分。其中取號、排隊和對銀行工作人員進行評分的業務對每個客戶是一樣的，可以在父類中實現，但是辦理具體業務卻因人而異，也因不同場景會不一樣，它可能是存款、取款或者轉賬等，應該要延遲到子類中實現。

這樣的例子在生活中還有很多，例如，一個人每天會起床、吃飯、做事、睡覺等，其中“做事”的內容每天可能不同。我們把這些規定了流程或格式的實例定義成模板，允許使用者根據自己的需求去更新它。

模板方法模式就是為了因應這種情境最適合的設計模式，下面就還介紹。

# 模式概述

模板方法（Template Method）模式的定義如下：定義一個操作中的算法骨架，而將算法當中動態變化的部分延遲到子類中，使得子類可以不改變該算法結構的情況下重定義該算法的某些特定步驟。屬於一種類行為型模式。

# 模式結構

模板方法模式包含的角色如下：

1. 抽象類/抽象模板（Abstract Class）

抽象模板類，負責給出一個算法的輪廓和骨架。它由一個模板方法和若干個基本方法構成。這些方法的定義如下：

- 模板方法：定義了算法的骨架，按某種順序調用其包含的基本方法。

- 基本方法：

| 方法 | 描述                                                                 |
| :------- | :------------------------------------------------------------------- |
| 抽象方法 | 在抽象類中聲明，由具體子類實現                                       |
| 具體方法 | 在抽象類中已經實現，在具體子類中可以繼承或重寫它                     |
| 鉤子方法 | 在抽象類中已經實現，包括用於判斷的邏輯方法(掛勾方法)和需要子類重寫的空方法兩種 |

2. 具體子類/具體實現（Concrete Class）

具體實現類，實現抽象類中所定義的抽象方法和鉤子方法，它們是一個頂級邏輯的一個組成步驟。

- 模式結構圖：

![](https://ftp.bmp.ovh/imgs/2021/06/d4a451f0ea466c17.png)

# 模式具體應用

來看看一個實際簡單實現了中介者模式的代碼，會更加直觀：

- 抽象模板類

```java
public abstract class AbstractClass {
    //模板方法
    public void TemplateMethod() {
        SpecificMethod();
        abstractMethod1();
        abstractMethod2();
    }
    //具体方法
    public void SpecificMethod() {
        System.out.println("抽象类中的具体方法被调用...");
    }
    //抽象方法1
    public abstract void abstractMethod1();
    //抽象方法2
    public abstract void abstractMethod2();
}
```

- 具體模板類

```java
public class ConcreteClass extends AbstractClass {
    public void abstractMethod1() {
        System.out.println("抽象方法1的实现被调用...");
    }
    public void abstractMethod2() {
        System.out.println("抽象方法2的实现被调用...");
    }
}
```

- Main

```java
public class Main {
    public static void main(String[] args) {
        AbstractClass template = new ConcreteClass();
        // 只調用模板方法
        template.TemplateMethod();
    }
}

// 抽象类中的具体方法被调用...
// 抽象方法1的实现被调用...
// 抽象方法2的实现被调用...
```
個人感覺這個模式相對易懂一點，上面的代碼應該也還算清楚，所以這邊就不再多做什麼分析。

通過上面的代碼應用了模板方法模式，當我們出現了一個新的基於 `AbstractClass` 算法的對象，只需要新建一個 `ConcreteClass1` 然後實現兩個抽象方法，並在實際使用時 new `ConcreteClass1` 就可以了。

# 優缺點
最後還是總結下關於模板方法模式的優缺點，如下：

該模式的主要 `優點` 如下：

1. 它封裝了不變部分，擴展可變部分。它把認為是不變部分的算法封裝到父類中實現，而把可變部分算法由子類繼承實現，便於子類繼續擴展。
2. 它在父類中提取了公共的部分代碼，便於代碼復用。
3. 部分方法是由子類實現的，因此子類可以通過擴展方式增加相應的功能，符合開閉原則，即對擴展開放、對修改關閉。

該模式的主要 `缺點` 如下。

1. 對每個不同的實現都需要定義一個子類，這會導致類的個數增加，系統更加龐大，設計也更加抽象，間接地增加了系統實現的複雜度。
2. 父類中的抽象方法由子類實現，子類執行的結果會影響父類的結果，這導致一種反向的控製結構。
3. 由於繼承關系自身的缺點，如果父類添加新的抽象方法，則所有子類都要改一遍。

